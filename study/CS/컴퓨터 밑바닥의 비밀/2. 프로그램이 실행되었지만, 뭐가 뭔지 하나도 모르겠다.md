## 2.1 운영 체제, 프로세스, 스레드의 근본 이해하기
### 2.1.1 모든 것은 CPU에서 시작된다
- CPU 는 뭐 아무것도 모르고 다음 두 가지만 안다
	- 메모리에서 명령어(instruction)를 하나 가져온다(dispatch)
	- 이 명령어를 실행(execute) 한 후 다시 위로 돌아가서 명령어를 하나 가져온다
- 최초의 PC 레지스터 값은 어떻게 설정 되는가?
	- 프로그램이 main 함수를 통해 실행 된다는 것을 기억해두자

### 2.1.2 CPU 에서 운영 체제까지
- 만약 운영 체제 없이 프로그램을 실행한다면
	- 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾는다
	- CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC 레지스터에 설정한다
- 결론은 프로그램의 main 함수의 진입점을 찾아 이런 저런 귀찮은 일들을 운영 체제가 다 해준다.. 라는 섹션

## 2.2 스레드 간 공유되는 프로세스 리소스
### 2.2.1 스레드 전용 리소스
- 스택 포인터(Stack Pointer)
	- 스레드가 실행될 때 생기는 스택 프레임의 상단 위치를 저장하는 녀석
- 스레드 로컬은 그냥 스레드 로컬 저장소라는 이름으로 통용 되는 듯 하다

## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?
### 2.3.1 자유와 제약
- 스레드는 공공장소

###  2.3.3 스레드 전용 리소스와 공유 리소스
- 프로세스의 메모리 구조
	- ------------------
	-            스택              -> 스레드가 생성한 영역
	- ~~~ 여유 공간 ~~~
	-              힙               -> 메모리의 동적 할당에 사용 되는 영역
	- ------------------
	-           데이터            -> 전역 변수가 저장 되는 영역
	- ------------------
	-             코드             -> 정적 데이터가 보관되는 영역, 런타임시 데이터가 수정되지 않음
	- ------------------
	- 이 중 `데이터` 영역과 `힙` 영역은 공유 리소스이므로, 이 두 영역에 존재하는 데이터를 다루는 코드는 스레드 안전해야 한다

### 2.3.5 스레드 전용 리소스와 함수 매개변수
```c
// ex-1. is Thread-safety?

int a = 1;

func(a);

int func(int num) {
	num++;
	return num;
}

println(a) // >> ? 
```

```c
// ex-2. is Thread-safety?

int a = 1;

func(&a);

int func(int* num) {
	++(*num);
	return *num;
}

println(a) // >> ? 
```
- ex-1 의 경우, 메모리 주소를 넘기지 않고 값만 넘기기 때문에(Call by value) 스레드 안전한 코드라고 할 수 있음
- 반면, ex-2 의 경우 a 의 메모리 주소를 넘기기 때문에(Call by reference) 스레드 안전한 코드라 할 수 없음
- 스레드 안전을 보장하는 꿀팁
	- 공유 리소스를 사용하지 말라 ㅎ

### 2.3.6 전역 변수 사용
- 그럼에도 불구하고 공유 리소스를 사용한다면
	- 초기화 된 이후에는 절대 수정하지 말라

### 2.3.7 스레드 전용 저장소
- C 언어에서 `__thread` 라는 키워드를 변수 앞에 붙이는 것으로 스레드 로컬을 선언하는 듯 하다

### 2.3.8 스레드 안전이 아닌 코드 호출하기
- 동기화 방법엔 대표적으로 아래와 같은 두 가지 방법이 존재
	- Mutex
		- 단 한 개의 스레드만이 공유 리소스를 점유할 수 있도록 공유 리소스를 제어하는 알고리즘의 일종
	* Semaphore
		* 뮤텍스와 하는 일은 같지만, 공유 리소스를 점유할 수 있는 대상 객체의 개수가 한 개 이상일 수 있는 알고리즘의 일종
		* 공유 리소스를 점유하려는 스레드/프로세스의 수를 `카운터` 로 관리

### 2.3.10 스레드 안전 코드는 어떻게 구현할까?
- 스레드 전용 저장소를 사용하거나
- 공유 리소스는 읽기 전용으로 만들거나
- 원자성 연산을 사용하거나
- 동기화 시 상호 배제를 고려해라

### 2.3 덤...
- C 언어와 Java 의 Atomic 연산 비교해보기
	- C 언어 계열의 경우, Java 와 마찬가지로 CPU 캐시에 적재된 데이터와 실제 메모리에 적재된 값이 다른 캐시 불일치 현상을 타파하는 것은 맞지만, 코드의 재배치 라는 키워드가 자주 등장한다
	- Java 는 CAS 연산 키워드가 주로 등장하는데.. 무슨 차이까 있을까? 🧐
		- `volatile` 키워드에서도 설명하면 재밌겠다.