## 3.1 메모리의 본질, 포인터와 참조
### 3.1.1 메모리의 본질은 무엇일까? 사물함, 비트, 바이트 ,객체
- 메모리의 가장 작은 단위 == 셀(cell)
- 당연히 0과 1만 저장 가능

## 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
### 3.2.1 가상 메모리: 눈에 보이는 것이 항상 실제와 같지는 않다
- 프로세스가 가상 메모리 쓴다는 챕터
- 프로세스의 메모리들은 실제 메모리에서는 분산 되어 저장 된다
	- 그러니까 한 프로세스의 메모리가 물리적인 공간에 연속되어 저장되지는 않는다는 말

## 3.3 스택 영역: 함수 호출은 어떻게 구현될까?
### 3.3.2 함수 호출 활동 추적하기: 스택
- 후입선출구조
### 3.3.3 스택 프레임 및 스택 영역: 거시적 관점
- stack frame == call stack
### 3.3.4 함수 점프와 반환은 어떻게 구현될까?
- 제어권이 이전될 때에는 다음 두 가지 정보가 필요하다
	- 반환(return): 어디에서 왔는가?
	- 점프(jump): 어디로 가는가?
- 즉, A 함수가 실행되며 B 함수가 실행될 때 알아야 할 것들
	- A 함수가 어디까지 실행 되었는가?
	- B 함수의 코드가 위치한 주소는 어디인가?
- 함수 호출은 호출자의 코드 데이터에 피호출자의 메모리 주소 맨 첫 번째 노드의 주소가 담겨 있어서, CPU 한테 이제 이 주소로 가서 함수를 실행하라고 알려주는 메커니즘으로 동작한다
	- 이렇게 CPU 가 다른 주소에 있는 함수 정보를 읽는 것을 `점프` 한다고 한다
- A 함수의 스택 프레임에는 B 함수를 호출하고난 뒤에 A 함수가 마저 수행해야할 코드의 주소가 담겨있다
- 이렇게 함수 B 가 실행되면, 함수 B 의 스택 프레임이 생성된다
- 함수 B 가 반환되면, 함수 B 의 호출자인 함수 A 로 이동하여 함수 A 의 스택 프레임에 존재하는 마저 수행해야할 코드의 주소를 보고 해당 주소부터 명령을 재개한다
- 결국 반환이라는 동작은 피호출자 함수의 동작이 종료되면 다시 호출자 함수로 돌아가 하던 일을 마저 하는 것...
### 3.3.5 매개변수 전달과 반환값은 어떻게 구현될까?
- x86 환경에서 매개변수를 전달하는 것과 반환값을 가져오는 작업은 주로 레지스터를 이용한다고 한다
	- 호출자 함수 A 가 피호출자 함수 B 를 호출하게 된다면, 함수 A 는 전달하려는 매개변수를 레지스터에 저장하고, CPU 가 함수 B 를 실행할 때 레지스터에서 매개변수 정보를 얻어올 수 있는 것이다.
	- 다른 레지스터가 아니고, CPU 의 레지스터가 맞다
	- 만약, 매개변수가 레지스터의 수보다 많다면, 매개변수는 호출자 함수의 스택 프레임에 넣고 피호출자 함수가 실행될 때 호출자 함수의 스택 프레임에서 매개변수 정보를 가져와 사용한다
### 3.3.7 레지스터의 저장과 복원
- 지역 변수도 사실 레지스터에 저장 되어 있어야 하는데, 개수가 많으면 스택 프레임에 저장 되어야 한다고....
- 하지만 레지스터의 크기는 매우 작다.. 그렇다면 레지스터에 저장되어야할 지역 변수는 어떻게 관리할까?
- 그래서 스택 프레임에 레지스터 초기값이 저장된다
	- 실행 중인 함수가 가져야할 레지스터 초기화 값이 아니라, 피호출자 함수가 실행되는 시점에 레지스터에 존재했던 값들이 저장 되는 것이다
	- 피호출자 함수의 실행이 종료되면 레지스터 값을 비우고 초기값으로 다시 복원 시켜 놓는다
### 3.3.8 큰 그림을 그려 보자, 우리는 지금 어디에 있을까?
- 너무 큰 지역 변수를 만들거나 함수 호출 단계가 너무 많으면 안된다
	- 이렇게 되면 스택 프레임 하나가 차지하는 크기가 너무 많아진다던가, 함수 호출이 너무 많이 이루어져 여러 개의 스택 프레임이 생기게 될 수도 있다는 말
	- 이렇게 발생하는 오류가 바로 stack overflow 이다
- 