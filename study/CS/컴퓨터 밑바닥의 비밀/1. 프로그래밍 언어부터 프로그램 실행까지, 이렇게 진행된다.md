- [[#1.1 여러분이 프로그래밍 언어를 발명한다면?|1.1 여러분이 프로그래밍 언어를 발명한다면?]]
	- [[#1.1 여러분이 프로그래밍 언어를 발명한다면?#1.1.1 창세기: CPU는 똑똑한 바보|1.1.1 창세기: CPU는 똑똑한 바보]]
	- [[#1.1 여러분이 프로그래밍 언어를 발명한다면?#1.1.5 <인셉션> 과 재귀: 코드 본질|1.1.5 <인셉션> 과 재귀: 코드 본질]]
- [[#1.2 컴파일러는 어떻게 작동하는 것일까?|1.2 컴파일러는 어떻게 작동하는 것일까?]]
	- [[#1.2 컴파일러는 어떻게 작동하는 것일까?#1.2.3 토큰이 표현하고자 하는 의미|1.2.3 토큰이 표현하고자 하는 의미]]
	- [[#1.2 컴파일러는 어떻게 작동하는 것일까?#1.2.6 코드 생성|1.2.6 코드 생성]]
- [[#1.3 링커의 말할 수 없는 비밀|1.3 링커의 말할 수 없는 비밀]]
	- [[#1.3 링커의 말할 수 없는 비밀#1.3.1 링커는 이렇게 일한다|1.3.1 링커는 이렇게 일한다]]
	- [[#1.3 링커의 말할 수 없는 비밀#1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일|1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일]]
	- [[#1.3 링커의 말할 수 없는 비밀#1.3.6 가상 메모리와 프로그램 메모리 구조|1.3.6 가상 메모리와 프로그램 메모리 구조]]
- [[#1.4 컴퓨터 과학에서 추상화가 중요한 이유|1.4 컴퓨터 과학에서 추상화가 중요한 이유]]
## 1.1 여러분이 프로그래밍 언어를 발명한다면?
### 1.1.1 창세기: CPU는 똑똑한 바보
- CPU 는 데이터를 한 곳에서 다른 곳으로 옮기고 간단히 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업 외에는 할 줄 모른다!
	- 다만 겁나 빠르다
### 1.1.5 <인셉션> 과 재귀: 코드 본질
$$
f(x) = f(x-1) + f(x-2) ...
$$
- 위 `f(x)` 라는 수식이 자식 수열에 의존하는 것 처럼, 한 개의 `명령어` 는 `자식 명령어` 에 의존한다
	- 이것이 재귀
- 이진 트리 같은 데이터 구조를 통해 고급 프로그래밍 언어가 탄생했다...
	- 구문 트리를 깊게 탐색 하다보면, 결국은 CPU가 이해할 수 있는 기계어가 나오게 된다

## 1.2 컴파일러는 어떻게 작동하는 것일까?
### 1.2.3 토큰이 표현하고자 하는 의미
- `토큰` 이란? 소스 코드를 잘게 쪼개서 의미 있는 정보를 함께 묶은 것
- 컴파일러는 소스 코트를 토큰으로 만들고, 이 토큰을 투리 형태로 구성한다
- 이렇게 컴파일러가 구문 트리를 생성하는 과정을 `구문 분석` 이라고 한다
- 생성된 구문 트리에 이상이 없는지 분석하는 과정을 `의미 분석(Semantic Analysis)` 이라고 한다
### 1.2.6 코드 생성
- 의미 분석이 끝난 구문 트리는 중간 코드로 변환할 수 있다
	- 경우에 따라 중간 코드에서 최적화가 진행 되기도 한다
	- e.g. 순환 구문 내 순환 상태와 관계 없이 계산 가능한 값이 있다면 순환 구문 외부에서 진행하도록 처리
- 이 과정이 모두 완료되면 중간 코드를 어셈블리어 코드로 변환한다
- 마지막으로 컴파일러는 어셈블리어 코드를 기계어로 변환한다

## 1.3 링커의 말할 수 없는 비밀
### 1.3.1 링커는 이렇게 일한다
- 링커의 역할 == 소스코드 파일을 한 데 모아주어 연결해준다
	- 그럼 연결은 어떻게 해 주냐.. C 의 경우 컴파일러는  `.o` 라는 목적 파일을 만들어 내는데, 이 파일이 컴파일 되는 시점에는 다른 파일에 정의된 코드가 어느 메모리 주소에 위치 하는지 정확하게 알 수 없다
	- 그래서 우선 임의의 표식을 해두고, 실제 실행 파일을 생성하는 과정에서 해당 코드의 정확한 주소를 알아낸 뒤 표식과 주소를 치환한다
- 아무래도 링커는 지역 변수보단 전역 변수에 더 관심이 많다
	- 지역 변수는 링크 할 게 없슴... 
- 목적 파일은 코드 영역과 데이터 영역, 심볼 테이블 영역으로 나뉜다
	- 코드 영역은 명령어가 저장되고
	- 데이터 영역은 데이터가 저장된다(`.o` 파일의 경우 전역 변수를 저장하는 듯 한데, 아마 다른 언어들도 비슷할 것... 어차피 C 기반이니)
	- 심볼 테이블 영역에는 외부 참조가 가능한 코드/데이터와 외부에서 참조하는 코드/데이터를 기록하는 영역이다
		- 컴파일러가 기록한다
### 1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일
- 정적 링크란, 각각의 파일을 개별적으로 컴파일하고 링크하여 정적 라이브러리로 시용하는 것
- 윈도우의 DLL 이 동적 라이브러리 라고 한다
### 1.3.6 가상 메모리와 프로그램 메모리 구조
- 32비트 시스템에서는 실제 머신의 메모리가 얼마던간에 자신이 2의 32승 바이트, 즉 4GB 만큼의 메모리를 독점하고 있다고 간주한다고 한다
- 64비트 시스템에서는 코드 영역의 메모리 주소는 언제나 `0x400000` 으로 시작한다고 하며, 스택 영역은 항상 메모리의 상위 주소에 위치한다고 한다
- 링커가 참조하는 메모리 주소는 사실상 물리 메모리 주소가 아니라 가상 메모리 주소인 셈
- 프로세스마다 `페이지 테이블` 이라는 개념을 두어, 가상 메모리 주소와 물리 메모리 주소를 매핑한다

## 1.4 컴퓨터 과학에서 추상화가 중요한 이유
### 1.4.2 시스템 설계와 추상화
- CPU -> 명령어 집합
- 기계 명령어 -> 고급 프로그래밍 언어
- 입출력 장치 -> 파일
- 실행 중인 프로그램 -> 프로세스
- 물리 메모리와 파일 -> 가상 메모리
- 네트워크 프로그래밍 -> 소켓
- 프로세스와 프로세스에 종속적인 실행 환경 -> 컨테이너
- CPU, 운영체제, 응용 프로그램 -> 가상 머신

---
# 느낀점
- 링커의 역할을 모호하게만 알고 있었는데, 굉장히 상세하게 기술해주어서 이해하기 쉬웠음
- 시스템 bit 수에 대해, 프로그램의 최대 메모리 제한이 비트 수에 따라 정해진다는 것은 처음 알게 되었다
	- 한 번에 처리될 수 있는 데이터의 크기이다- 정도만 알고 있었는데, 이렇게 총 메모리 제한이 있다는 것은 몰랐당
- 추상화 광인으로써, 추상화에 대한 서브 챕터가 있는 것이 좋았다
	- 컴퓨터 과학의 추상화의 역사를 짧고 명료하게 설명한 챕터라고 생각한다
	- 특히 '제 컴퓨터에선 잘 되는데요' 가 이제는 컨테이너 환경이 보편화됨에 따라, 사장된 변명이라고 콕 집어준 것이 마음에 들었다
- 추상화 관련하여, 네트워크 프로그래밍이 소켓이라는 키워드로 축약될 수 있다는 것이 좀 흥미로웠다
	- 네트워크 지식이 많이 없으니, 조만간 꼭 사놓고 안보고 있는 네트워크 강의를 이제는 봐야겠다..